In this section, we discuss some threats to validity, cases that are not handled by our mitigations, and future directions for improving the approach of updating deprecated API usage in Android apps.
\subsection{Threats to Validity}
We have tried our best to rerun AppEvolve following the instructions given by the authors in the AppEvolve documentation. We have also asked the first author questions on how to configure AppEvolve correctly for new mobile applications that need to be updated. Still, we might have make wrong configurations unintentionally. We tried to minimize the chance of this happening by checking the configurations that we created multiple times to ensure that we have configured everything correctly.

We have added 54 new applications to evaluate the effectiveness of AppEvolve in generating applicable updates. This translates to 54 API usages location on top of 41 API usage locations in AppEvolve dataset, which more than doubles the dataset size from the original work. We believe this is sufficient as 44 of the API usages that we added uncovers many limitations of AppEvolve. There might be other cases that AppEvolve cannot handle, but we believe that we have found many of them.


\subsection{Cases Outside Our Mitigations}
For other cases where our mitigations do not work, we alter the code until the learned edits can be successfully applied by AppEvolve. The goal is to confirm the cause of the failed update. 

\begin{enumerate}
\item We modify the code in Listing~\ref{lst:static} to the one below.
\begin{lstlisting}[language=text,numbers=none]
private static AudioManager mAudioManager;
public static void requestAudioFocus
    (Context context) {
    if(mAudioManager == null){
        mAudioManager = (AudioManager) context
            .getApplicationContext()
            .getSystemService(Context.AUDIO_SERVICE);
    }
    int res;
    int a = AudioManager.STREAM_MUSIC;
    int b = AudioManager.AUDIOFOCUS_GAIN;
    AudioManager am = mAudioManager;
    AudioManager.OnAudioFocusChangeListener
        af = afChangeListener;
    res = am.requestAudioFocus(af,a,b);
}
\end{lstlisting}
In Listing~\ref{lst:static}, {\tt afChangeListener} of type {\tt AudioManager.OnAudioFocusChangeListener} is directly put as the first argument of {\tt requestAudioFocus} and AppEvolve cannot generate an applicable update. When {\tt afChangeListener} is assigned to a local variable named {\tt af} as above, AppEvolve can generate an applicable update.

\item We modify the code in Listing~\ref{lst:final} to the one below.
\begin{lstlisting}[language=text,numbers=none]
private Paint paint;
  @Override protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawColor(Color.GREEN);
    float a = 0;
    float b = 0;
    float c = getWidth();
    float d = getHeight();
    int flag = Canvas.CLIP_SAVE_FLAG;
    canvas.saveLayer(a,b,c,d, paint, flag);
    canvas.restore();
  }
\end{lstlisting}
In Listing~\ref{lst:final}, a field named {\tt paint} of type {\tt Paint} has a {\tt final} modifier. Removing this modifier results in an applicable update. It suggests that AppEvolve does not support {\tt final} modifier.
\end{enumerate}


\subsection{Future Directions}
Our mitigations can fix 81.82\% of the failed updates that we found, which shows a promise of simple modifications of target app to update for assuring that edits that are learned from examples of API usage can be applied successfully. This technique can possibly be generalized by normalizing the code into a standard form. Edits can then be learned from this standard form. When the edits is applied to a new piece of code, the new piece of code should also be normalized to a standard form, which should minimizes variations of code due to simple refactorings. The learned edits can then be applied to the normalized code. If the edits are successfully applied, the resultant code is then denormalized following the way it was written before the code is normalized. In other words, the denormalization process should preserve the coding style before normalization.

Our mitigations represent a subset of normalization that is possible. We evaluate whether the generated code has a good readability by simulating normalization that may be generated by machine. We first normalize the app code using our mitigations to make the edits learned by AppEvolve applicable. We then take the resultant code as the code generated by AppEvolve. We then ask a research engineer that is not the author of this paper to generate an update to the same application. We take the resultant updated code as the code generated by human. We compare code quality of these two cases.


One of the important feature that determine the quality of a code is its readability. Buse and Weimer~\cite{Buse:2008:MSR:1390630.1390647} propose a metric of software readability that is based on a set of simple local features. They also provide an automatic readability measure model that is built on 12,000 code readability judgments. We run this model and compare the readability measure of the API update created by human against the update created by AppEvolve.
\begin{itemize}
\item AppEvolve Update:
\begin{lstlisting}[language=text,numbers=none]
public void displayTime(View view){
  int time;
  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
    time=timePicker.getHour();
  }
  else {
    time=timePicker.getCurrentHour();
  }
  Toast.makeText(this,time,Toast.LENGTH_SHORT).show();
}
\end{lstlisting}
Readability score: 0.006027444265782833


\item Human Update:
\begin{lstlisting}[language=text,numbers=none]
public void displayTime(View view) {
    // function to display the current time
    int currentHour;
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
        currentHour = timePicker.getHour();
    } else {
        currentHour = timePicker.getCurrentHour();
    }
    Toast.makeText(this, currentHour, Toast.LENGTH_SHORT).show();
}
\end{lstlisting}
Readability score: 0.0067915963008999825
\end{itemize}

Result from the automated readability measure shows that API update created by human achieves higher readability than the one created by AppEvolve. Differences between the update are in the aspect of code style, in which the human code has spacing in between operand and variable while AppEvolve code does not. Human code also have more indentation which creates higher readability. Furthermore, update by AppEvolve removes any comment inside the code block, which can significantly reduce the readability of the code.

The result above suggests that simple refactoring (and possibly code normalization) may lead to API usage update with lower readability that the ones written by human. To improve readability, we can recommend identifier names to newly introduced variables~\cite{...}.
In this section, we discuss some threats to validity, cases that are not
handled by our mitigations, and future directions for improving the
approach to updating deprecated API usage in Android apps.

\subsection{Threats to Validity}

We have tried our best to run AppEvolve following the instructions given by
the authors in the AppEvolve documentation. We have also asked the first
author how to configure AppEvolve correctly for new mobile
applications. Still, we might have made wrong configurations
unintentionally. We tried to minimize the chance of this happening by
manually rechecking our configurations.

We have added 54 new applications to evaluate the effectiveness of
AppEvolve in generating applicable updates. This translates to 54 API usage
locations on top of the 41 API usage locations in AppEvolve dataset, thus
more than doubling the size of the dataset used in the original work. We
believe this is sufficient to understand the capabilities of AppEvolve, as
44 of the 54 API usages that we have added uncover limitations of
AppEvolve. There might be other cases that AppEvolve cannot handle, but we
believe that we have found many of them.


\subsection{Cases Outside Our Mitigations}
For cases where our mitigations do not work, we alter the target code until
AppEvolve can successfully apply the learned edits. The goal is to
understand the cause of the failure.

\begin{enumerate}
\item We modify the code in the left hand side of Listing 7 in Table~\ref{tab:mitigatefail} to the one below.
\begin{lstlisting}[language=text,numbers=none]
private static AudioManager mAudioManager;
public static void requestAudioFocus
    (Context context) {
    if(mAudioManager == null){
        mAudioManager = (AudioManager) context
            .getApplicationContext()
            .getSystemService(Context.AUDIO_SERVICE);
    }
    int res;
    int a = AudioManager.STREAM_MUSIC;
    int b = AudioManager.AUDIOFOCUS_GAIN;
    AudioManager am = mAudioManager;
    AudioManager.OnAudioFocusChangeListener
        af = afChangeListener;
    res = am.requestAudioFocus(af,a,b);
}
\end{lstlisting}
In the above listing, {\tt afChangeListener} of type {\tt AudioManager.OnAudioFocusChangeListener} is directly put as the first argument of {\tt requestAudioFocus} and AppEvolve cannot generate an applicable update. When {\tt afChangeListener} is assigned to a local variable named {\tt af} as above, AppEvolve can generate an applicable update.

\item We modify the code in the left hand side of Listing 8 in Table~\ref{tab:mitigatefail} to the one below.
\begin{lstlisting}[language=text,numbers=none]
private Paint paint;
  @Override protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawColor(Color.GREEN);
    float a = 0;
    float b = 0;
    float c = getWidth();
    float d = getHeight();
    int flag = Canvas.CLIP_SAVE_FLAG;
    canvas.saveLayer(a,b,c,d, paint, flag);
    canvas.restore();
  }
\end{lstlisting}
In the above listing, a field named {\tt paint} of type {\tt Paint} has a {\tt final} modifier. Removing this modifier results in an applicable update. It suggests that AppEvolve does not support {\tt final} modifier.
\end{enumerate}


\subsection{Future Directions}
Our mitigations can fix 81.82\% of the failed updates that we found,
showing that even simple modifications of the target apps can allow
edits that are learned from examples of API usage to be applied
successfully. This technique can possibly be generalized by normalizing the
code into a standard form. Edits can then be learned from this standard
form. When the edit is applied to a new piece of code, that target code
should also be normalized, which should minimize the variations in the code
due to simple refactorings. If the edits are successfully applied, the
resulting code can then be denormalized following the original coding
style.  Our mitigations represent a subset of the normalizations that are
possible.

If perfect denormalization is not possible, it is necessary to consider the
impact of normalization on readability. We first normalize the app code
using our mitigations to make the edits learned by AppEvolve applicable. We
then take the resulting code as the code generated by AppEvolve. We then
ask a research engineer who is not an author of this paper to generate an
update to the same application. We take the resulting updated code as the
code generated by human. We compare the code readability of these two cases.

Buse and Weimer~\cite{Buse:2008:MSR:1390630.1390647} propose a metric of
software readability that are based on a set of simple local features. They
also provide an automatic readability measure model that is built on 12,000
code readability judgments. We run this model and compare the readability
measure of the API update created by AppEvolve against that of the update
created by the human.  Scores range from 0 to 1 where, 0 is least and 1 is
most readable.

\jl{We need to know what was the original code.}

\begin{itemize}
\item AppEvolve Update:
\begin{lstlisting}[language=text,numbers=none]
public void displayTime(View view){
  int time;
  if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
    time=timePicker.getHour();
  }
  else {
    time=timePicker.getCurrentHour();
  }
  Toast.makeText(this,time,Toast.LENGTH_SHORT).show();
}
\end{lstlisting}
Readability score: 0.006027444265782833


\item Human Update:
\begin{lstlisting}[language=text,numbers=none]
public void displayTime(View view) {
    // function to display the current time
    int currentHour;
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP) {
        currentHour = timePicker.getHour();
    } else {
        currentHour = timePicker.getCurrentHour();
    }
    Toast.makeText(this, currentHour, Toast.LENGTH_SHORT).show();
}
\end{lstlisting}
Readability score: 0.0067915963008999825
\end{itemize}

The difference in readability is very small. Indeed, the human developer
also implicitly performed the normalization, and the differences between
the variants are due to the choice of variable names, the spacing around
function arguments and the degree of indentation.  Recent research has
proposed strategies to automate the selection of new variable
names~\cite{...}.  The other issues can be addressed by tools such as
\jl{indent?  Apparently it only targets C programs} that are
parameterizable according to the desired coding style.

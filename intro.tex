In recent years, each release of Android has seen the deprecation of some
APIs and the introduction of new ones.  Due to the fragmentation of the
Android user base~\cite{he2018understanding,li2018cid}, app developers must update their apps to use the new
APIs, while maintaining backward compatibility.  Unfortunately, updating
APIs is not always trivial.  While API changes are described in the
documentation, these descriptions are not always accompanied by concrete
examples.  Moreover, an API may be used at many places in the app source
code, and thus updating its uses may be tedious and error prone.

%Mobile apps are an integral part of a modern life. To keep up with increasing users' needs and demands, they may need to be frequently updated following the frequent updates of the underlying mobile operating system (OS)~\cite{bavota2014impact,han2012understanding,linares2013api,mcdonnell2013empirical,yang2018android}. App developers may need to maintain backward compatibility with different versions of the mobile OS to reach as many users as possible. To do so, developers need to update the APIs accordingly so that the same mobile apps can run without problems in the past and future versions of the mobile OS.

%Unfortunately, updating APIs correctly is not always trivial. While API changes are described in documentation, examples of how to adapt to the API changes are not always available, especially if there is a need to maintain backward compatibility due to OS fragmentation~\cite{he2018understanding,li2018cid}. Moreover, the APIs to update may be used in many different locations in the mobile apps and thus updating them manually one by one is time consuming and error prone.

%To automate the process of updating Android apps, Fazzini et al. proposed a technique named AppEvolve~\cite{fazzini2019automated}. To the best of our knowledge, AppEvolve is the state-of-the-art technique for automatic update of API-usage for Android apps. More specifically, it targets updates of deprecated-API usages. AppEvolve works by collecting information from existing code examples that already have gone through the update process. 

AppEvolve was recently proposed by Fazzini et al.~\cite{fazzini2019automated} to
automate the updating of Android apps in response to deprecations of
Android APIs.  AppEvolve works by collecting information from existing code
that has already been updated to use the new APIs. 
AppEvolve accepts as input a target Android app and information about API changes between two Android versions. It works in four phases. The first phase identifies code fragments in the target app that are affected by the API change. The second phase searches existing codebases for examples of the API change. The third phase generalizes each example into a form of generic code patch. These code patches are then ranked. In the fourth and final phase, it applies the generic code patches one at a time according to their ranking. Successful application means that AppEvolve can produce an applicable  update. The applicable update is validated if testing runs without errors. AppEvolve has been evaluated on a dataset involving 15 real-world apps and 20 real API changes. The dataset contains 41 usage locations of these real API changes. AppEvolve successfully produced applicable updates for 85\% of these API changes and 90.24\% of their usage locations. 

In this work, our goal is to analyze the characteristics of cases in which AppEvolve cannot generate applicable updates. Given the original dataset that is made available by AppEvolve authors\footnote{\url{https://sites.google.com/view/appevolve}}, we searched for additional mobile apps that use the same deprecated APIs in the original AppEvolve dataset. We found 54 mobile apps with 16 real API changes and 54 usage locations. 

We applied AppEvolve to update these mobile apps and analyzed in detail the cases where it fails to update the apps. Running AppEvolve on our dataset results in the generation of 10 applicable updates and 44 failed updates. Our analysis shows that AppEvolve produces applicable updates for a mobile app in cases where the API usage match the API change examples.  On the other hand, in most cases, AppEvolve fails to update a mobile app due to minor syntactical difference between invocation of the deprecated method in the example and the target app. It also fails when encountering edits that require modifications beyond method boundaries, coming across unsupported programming language features, and finding no examples  in GitHub.

We mitigate cases of minor syntactical difference by performing simple refactoring in order to convert the target app code to resemble the example from which AppEvolve learns the edits from. After this simple refactoring, we found that AppEvolve can generate applicable updates for 81.82\% of cases where it previously failed to do so. Based on the discovered limitations in AppEvolve and our mitigations result, we propose promising future directions, such as normalizing code to a standard form coupled with identifier name recommendation, to improve existing work on automated deprecated-API usage updates in Android apps.

The main contributions of this paper are as follows:
\begin{itemize}
	\item We  evaluate AppEvolve with additional Android apps to investigate if it can effectively perform API-usage updates in different situations. The dataset that we created contains more than three times the number of real-world apps used to evaluate AppEvolve in the original paper (54 vs 15).
	\item We categorize the limitations of AppEvolve and show API usage instances in which these limitations are apparent.
	\item We discuss how the limitations may be overcome to improve the automatic API-usage update for Android apps.
	\item We release a replication package to allow easy replication and evaluation of our experiments and results.\footnote{\url{...}}
\end{itemize}

The remainder of this paper is structured as follows. Section~\ref{sec:approach} describes AppEvolve, the state-of-the-art work on automatic update of deprecated APIs in Android apps. Section~\ref{sec:replication} presents our replication settings. Section~\ref{sec:findings} presents our findings. Section~\ref{sec:mitigations} presents mitigations for some failed updates of Android apps. In Section~\ref{sec:discuss}, we discuss our findings. Section~\ref{sec:related} presents some related work. Last but not least, Section~\ref{sec:conclusion} concludes and presents some future work.
%In this section, we present prior works on API deprecation, API evolution, and API migration.
\subsection{API Deprecation}
There are a lot of works that focus on studying API deprecation~\cite{zhou2016api,kapur2010refactoring,raemaekers2014semantic,brito2016developers,robbes2012developers,sawant2016reaction,sawant2018features,li2018characterising}. Zhou and Walker~\cite{zhou2016api} found that, in practice, deprecating APIs does not always follow {\em deprecated-replace-remove} cycle, such as many deprecated APIs are undeprecated. They also developed a tool to warn about deprecated API usages in StackOverflow posts. Kapur et al.~\cite{kapur2010refactoring} found that APIs might be removed without being marked as deprecated. Raemaekers et al.~\cite{raemaekers2014semantic} discovered that some Java artifacts on the Maven Central Repository never remove deprecated APIs. Brito et al.~\cite{brito2016developers} showed that not all APIs are annotated with replacement messages. Robbes et al.~\cite{robbes2012developers} analyzed the Smalltalk ecosystem and showed that some API changes caused by deprecation can substantially impact the ecosystem. This study was replicated on the Java ecosystem and similar results were reported~\cite{sawant2016reaction,sawant2018reaction}, except that the number of deprecated API replacements was higher in the Smalltalk ecosystem. Sawant et al.~\cite{sawant2018features} created a taxonomy containing 12 reasons for deprecation and developed an approach to automatically classify them. Li et al.~\cite{li2018characterising} performed an exploratory study on characterizing Android APIs. They found that, among other things, deprecated Android APIs are not always consistently annotated and documented, and they are also regularly cleaned up. They have also developed a prototype tool that can generate API replacement mappings from the Android framework source code. %However, the automatically generated mappings may not be correct. In contrast, we have manually curated our dataset of 647 deprecated method mappings.
%\lx{"these mappings"? It sounds like the mappings auto-generated by Li et al. are correct? May be better to give some numbers to show how our curated dataset is different from their mappings.}

All of the above studies aim to understand API deprecation. In this work,
we aim to understand the applicability of a state-of-the-art approach for
automatic update of Android apps, which updates uses of deprecated methods to
corresponding uses of their replacement methods.

%% \subsection{API Evolution}

%% There are many works that focus on supporting API
%% evolution~\cite{henkel2005catchup,schafer2008mining,wu2010aura,dagenais2009semdiff,dagenais2011recommending,meng2012history,yu2017api}. Henkel
%% et al.~\cite{henkel2005catchup} created a tool named CatchUp! that records
%% developers' refactoring actions when evolving uses of an API within an
%% Integrated Development Editor (IDE) and can replay them afterwards. Xing et
%% al.~\cite{xing2007api} proposed Diff-CatchUp!, a tool that recommends
%% plausible replacements for obsolete API usages following example changes in
%% the API change history.  Sch{\"a}fer et al.~\cite{schafer2008mining}
%% proposed to mine API replacement rules for API evolution by analyzing
%% client code that has performed the replacements. Dagenais and
%% Robillard~\cite{dagenais2009semdiff,dagenais2011recommending} proposed an
%% approach named SemDiff that learns how an API adapts to its own changes and
%% uses this information to recommend a set of method replacements to client
%% programs. Wu et al.~\cite{wu2010aura} developed a tool named AURA to mine
%% API replacement rules using a combination of method call dependency
%% analysis and text similarity. Meng et al.~\cite{meng2012history} proposed
%% HiMA, a tool that infers API replacement rules between two versions of a
%% framework by aggregating API replacement rules for each pair of consecutive
%% revisions in the framework history between the two versions. Yu et
%% al.~\cite{yu2017api} develop an approach named AUC-Miner, which mines API
%% replacement rules by employing context information to refine method call
%% dependency analysis.

%% %In this work, given the API replacement rules, our approach generates transformation rules, in the form of semantic patches, that can be used to perform the API replacement. Thus, our approach complements approaches that mine API replacement rules.

%% \subsection{API Migration}

%% Many works have been proposed to support API migration in varying
%% situations~\cite{hora2015apiwave,zhou2016api,nguyen2010graph,nguyen2014statistical,nita2010using,lamothe2018a4}. Nita
%% and Notkin~\cite{nita2010using} proposed the use of twinning (i.e., a
%% technique to specify program changes without modifying the program
%% directly) to migrate a program to use alternative APIs. Hora and
%% Valente~\cite{hora2015apiwave} proposed Apiwave, a tool for tracking API
%% popularity and migration. Zhong et al.~\cite{zhou2016api} developed a tool
%% called MAM, which mines API mappings for language migration from programs
%% with two v<ersions in two programming languages. Nguyen et
%% al.~\cite{nguyen2010graph} developed LIBSYNC, which employs a graph based
%% approach to migrate API usage in client code to the new version of the API
%% by learning from clients that have performed the adaptations. Nguyen et
%% al.~\cite{nguyen2014statistical} proposed StaMiner, a statistical model
%% based approach to mine API mappings for migrating programs from one
%% language to another. Lamonthe et al.~\cite{lamothe2018a4} proposed an
%% approach that learns API migration patterns from code examples and can
%% apply these patterns to migrate deprecated APIs.

\subsection{Replication Studies}

There have been a number of replication studies in the software engineering
domain \cite{Chen:2017:CLP:3042021.3042046,
  Greiler:2015:COS:2820518.2820522, Akbarinasaji:2018:PBT:3174380.3174639,
  Dinh-Trong:2005:FPR:1079843.1080069, howdopython} that have not always
confirmed the original results. Chen and
Jiang~\cite{Chen:2017:CLP:3042021.3042046} replicated a study by Yuan et
al.~\cite{Yuan:2012:CLP:2337223.2337236} of logging practices.  In contrast
to the observations of Yuan et al., Chen and Jiang found that bug reports
without a log message take a shorter time to resolve than bug reports that
include a log.  Greiler et al.~\cite{Greiler:2015:COS:2820518.2820522}
replicated the work of Bird et al.~\cite{Bird:2011:DTM:2025113.2025119} on
the correlation between code ownership and software quality.  Greiler et
al. used new and refined code ownership metrics and prediction
models. Akbarinasaji et al.~\cite{Akbarinasaji:2018:PBT:3174380.3174639}
replicated and reinforced the finding on the bug fixing time estimation
model by showing similar result with the previous work. A replication study
on open source development by Trong et
al.~\cite{Dinh-Trong:2005:FPR:1079843.1080069} found new findings from the
previous work by Mockus et al.~\cite{Mockus:2002:TCS:567793.567795}. They
supported some of the previous hypotheses and proposed revisions on hypothesis related to the need of formal arrangement for work coordination and on hypothesis regarding the number of core developers on open source project. A
replication study by Orru et al.~\cite{howdopython} conducted an analysis
of the use of inheritance in Python systems that was previously done on
Java. Their result shows that compared on the previous findings on Java,
Python has more classes that are inherited from but fewer classes that inherit from other
classes.

%Among the API migration work above, Lamonthe et al.'s work is the closest to our work. Our work also deals with API migration, particularly replacing deprecated APIs. However, different than their work, our work focuses on the scenario in which there are no examples. 

% \subsection{API Usage Recommendation}
% Several approaches have been developed to recommend and explore how an API can be used~\cite{glassman2018visualizing}. Glassman et al.~\cite{glassman2018visualizing} proposed EXAMPLORE, an tool that summarizes hundreds of code examples for an API in a single view.


\subsection{Program Transformation}

Normalization of code to improve the results of program transformations has
a long history.  It was extensively used in the early 1990s in the context
of partial evaluation (specialization of programs to the values of some
known inputs), in the form of {\em binding-time improvements}, in order to
bring known values closer together, to allow code simplifications
\cite{some,things}.  \jl{X} and \jl{Y} have more generally studied and
formalized the impact of program transformations on program optimizations
\cite{paper_from_david}.

AppEvolve is also part of a line of research that has recently been
attracting increasing interest on inferring program transformations from
one or more examples.  LASE~\cite{Meng:2013:LLA:2486788.2486855} creates an
edit script from examples, locate the edit locations \jl{really?}, and do
the code transformation
automatically. REFAZER~\cite{Rolim:2017:LSP:3097368.3097417} is a technique
for automatic program transformation generation that is build based on code
edits performed by developers as input-output
examples. Genesis~\cite{Long:2017:AIC:3106237.3106253} automatically infers
patch generation transforms from previous successful
patches. PHOENIX~\cite{Bavishi:2019:PAD:3338906.3338952} is a fully
automated pipeline system that mines and cleans patches from examples and
learns generalized executable repair strategies by leveraging a novel
Domain Specific Language
(DSL). Spdiff~\cite{Andersen:2012:SPI:2351676.2351753} infers
transformation specifications from examples of both original and updated
code.
\jl{These descriptions should be improved.  We don't see how the
  capabilities of these tools relate to each other, not how they relate to
  the capabilities of AppEvolve.}

\subsection{Program Transformation}

\jl{alternate section, need to merge}

Research on program transformation have been done in multiple works~\cite{Visser:2001:SLP:647200.718711, Meng:2013:LLA:2486788.2486855, Rolim:2017:LSP:3097368.3097417,Long:2017:AIC:3106237.3106253, Bavishi:2019:PAD:3338906.3338952, Andersen:2012:SPI:2351676.2351753}. Visser~\cite{Visser:2001:SLP:647200.718711, 10.1007/978-3-540-87875-9_13, Lee:2013:DRI:2486788.2486792, Nguyen:2019:GMI:3339505.3339608} proposed Stratego, a language for program transformation that is based on rewriting strategies. Stratego aims to make reusable transformation rules that can be used in multiple transformations by separating the strategies from the transformation rules. Meng et al.~\cite{Meng:2013:LLA:2486788.2486855} developed LASE, a tool that can create edit script from examples, locate the edit locations, and do the code transformation automatically. Rolim et al.~\cite{Rolim:2017:LSP:3097368.3097417} proposed REFAZER, a technique for automatic program transformation generation which is build based on code edits performed by developers as input-output examples. Long et al.~\cite{Long:2017:AIC:3106237.3106253} proposed Genesis which can automatically infer patch generation transforms from previous successful patches. Bavishi et al.~\cite{Bavishi:2019:PAD:3338906.3338952} developed PHOENIX, a fully automated pipeline system that mines and clean patches from examples and learns generalized executable repair strategies by leveraging a novel Domain Specific Language (DSL). Andersen et al.~\cite{Andersen:2012:SPI:2351676.2351753} proposed the tool spdiff that can infer transformation specifications from examples of both original and updated code. Robbes and Lanza~\cite{10.1007/978-3-540-87875-9_13} presented a system that support example-based program transformation. The system takes an example manual change by developer and generalizes it to other application contexts. Lee et al.~\cite{Lee:2013:DRI:2486788.2486792} implemented DNDRefactoring, a tool that streamline the configuration and invocation of refactoring system through the use of direct manipulation via drag-and-drop. Nguyen et al.~\cite{Nguyen:2019:GMI:3339505.3339608} proposed a graph-based mining approach on detecting repetitive code changes called as CPatMiner. This approach aims to detect semantic code change patterns from large corpus and present them as graph.

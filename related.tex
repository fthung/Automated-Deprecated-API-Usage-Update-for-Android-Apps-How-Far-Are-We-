%In this section, we present prior works on API deprecation, API evolution, and API migration.
\subsection{API Deprecation}
There are a lot of works that focus on studying API deprecation~\cite{zhou2016api,kapur2010refactoring,raemaekers2014semantic,brito2016developers,robbes2012developers,sawant2016reaction,sawant2018features,li2018characterising}. Zhou and Walker~\cite{zhou2016api} found that, in practice, deprecating APIs does not always follow {\em deprecated-replace-remove} cycle, such as many deprecated APIs are undeprecated. They also developed a tool to warn about deprecated API usages in StackOverflow posts. Kapur et al.~\cite{kapur2010refactoring} found that APIs might be removed without being marked as deprecated. Raemaekers et al.~\cite{raemaekers2014semantic} discovered that some Java artifacts on the Maven Central Repository never remove deprecated APIs. Brito et al.~\cite{brito2016developers} showed that not all APIs are annotated with replacement messages. Robbes et al.~\cite{robbes2012developers} analyzed the Smalltalk ecosystem and showed that some API changes caused by deprecation can substantially impact the ecosystem. This study was replicated on the Java ecosystem and similar results were reported~\cite{sawant2016reaction,sawant2018reaction}, except that the number of deprecated API replacements was higher in the Smalltalk ecosystem. Sawant et al.~\cite{sawant2018features} created a taxonomy containing 12 reasons for deprecation and developed an approach to automatically classify them. Li et al.~\cite{li2018characterising} performed an exploratory study on characterizing Android APIs. They found that, among other things, deprecated Android APIs are not always consistently annotated and documented, and they are also regularly cleaned up. They have also developed a prototype tool that can generate API replacement mappings from the Android framework source code. %However, the automatically generated mappings may not be correct. In contrast, we have manually curated our dataset of 647 deprecated method mappings.
%\lx{"these mappings"? It sounds like the mappings auto-generated by Li et al. are correct? May be better to give some numbers to show how our curated dataset is different from their mappings.}

All of the above studies aim to understand API deprecation. In this work,
we aim to understand the applicability of a state-of-the-art approach for
automatic update of Android apps, which updates uses of deprecated methods to
corresponding uses of their replacement methods.

%% \subsection{API Evolution}

%% There are many works that focus on supporting API
%% evolution~\cite{henkel2005catchup,schafer2008mining,wu2010aura,dagenais2009semdiff,dagenais2011recommending,meng2012history,yu2017api}. Henkel
%% et al.~\cite{henkel2005catchup} created a tool named CatchUp! that records
%% developers' refactoring actions when evolving uses of an API within an
%% Integrated Development Editor (IDE) and can replay them afterwards. Xing et
%% al.~\cite{xing2007api} proposed Diff-CatchUp!, a tool that recommends
%% plausible replacements for obsolete API usages following example changes in
%% the API change history.  Sch{\"a}fer et al.~\cite{schafer2008mining}
%% proposed to mine API replacement rules for API evolution by analyzing
%% client code that has performed the replacements. Dagenais and
%% Robillard~\cite{dagenais2009semdiff,dagenais2011recommending} proposed an
%% approach named SemDiff that learns how an API adapts to its own changes and
%% uses this information to recommend a set of method replacements to client
%% programs. Wu et al.~\cite{wu2010aura} developed a tool named AURA to mine
%% API replacement rules using a combination of method call dependency
%% analysis and text similarity. Meng et al.~\cite{meng2012history} proposed
%% HiMA, a tool that infers API replacement rules between two versions of a
%% framework by aggregating API replacement rules for each pair of consecutive
%% revisions in the framework history between the two versions. Yu et
%% al.~\cite{yu2017api} develop an approach named AUC-Miner, which mines API
%% replacement rules by employing context information to refine method call
%% dependency analysis.

%% %In this work, given the API replacement rules, our approach generates transformation rules, in the form of semantic patches, that can be used to perform the API replacement. Thus, our approach complements approaches that mine API replacement rules.

%% \subsection{API Migration}

%% Many works have been proposed to support API migration in varying
%% situations~\cite{hora2015apiwave,zhou2016api,nguyen2010graph,nguyen2014statistical,nita2010using,lamothe2018a4}. Nita
%% and Notkin~\cite{nita2010using} proposed the use of twinning (i.e., a
%% technique to specify program changes without modifying the program
%% directly) to migrate a program to use alternative APIs. Hora and
%% Valente~\cite{hora2015apiwave} proposed Apiwave, a tool for tracking API
%% popularity and migration. Zhong et al.~\cite{zhou2016api} developed a tool
%% called MAM, which mines API mappings for language migration from programs
%% with two versions in two programming languages. Nguyen et
%% al.~\cite{nguyen2010graph} developed LIBSYNC, which employs a graph based
%% approach to migrate API usage in client code to the new version of the API
%% by learning from clients that have performed the adaptations. Nguyen et
%% al.~\cite{nguyen2014statistical} proposed StaMiner, a statistical model
%% based approach to mine API mappings for migrating programs from one
%% language to another. Lamonthe et al.~\cite{lamothe2018a4} proposed an
%% approach that learns API migration patterns from code examples and can
%% apply these patterns to migrate deprecated APIs.

\subsection{Replication Studies}

There have been a number of replication studies in the software engineering
domain \cite{Chen:2017:CLP:3042021.3042046,
  Greiler:2015:COS:2820518.2820522, Akbarinasaji:2018:PBT:3174380.3174639,
  Dinh-Trong:2005:FPR:1079843.1080069, howdopython} that have not always
confirmed the original results. Chen and
Jiang~\cite{Chen:2017:CLP:3042021.3042046} replicated a study by Yuan et
al.~\cite{Yuan:2012:CLP:2337223.2337236} of logging practices.  In contrast
to the observations of Yuan et al., Chen and Jiang found that bug reports
without a log message take a shorter time to resolve than bug reports that
include a log.  Greiler et al.~\cite{Greiler:2015:COS:2820518.2820522}
replicated the work of Bird et al.~\cite{Bird:2011:DTM:2025113.2025119} on
the correlation between code ownership and software quality.  Greiler et
al. used new and refined code ownership metrics and prediction
models. Akbarinasaji et al.~\cite{Akbarinasaji:2018:PBT:3174380.3174639}
replicated and reinforced the finding on the bug fixing time estimation
model by showing similar result with the previous work. A replication study
on open source development by Trong et
al.~\cite{Dinh-Trong:2005:FPR:1079843.1080069} found new findings from the
previous work by Mockus et al.~\cite{Mockus:2002:TCS:567793.567795}. They
supported some hypotheses and proposed some revisions for hypotheses
related to formal arrangement \jl{means what?} and core developers. A
replication study by Orru et al.~\cite{howdopython} conducted an analysis
of the use of inheritance in Python systems that was previously done on
Java. Their result shows that compared on the previous findings on Java,
more classes are inherited from but fewer classes inherit from other
classes.

%Among the API migration work above, Lamonthe et al.'s work is the closest to our work. Our work also deals with API migration, particularly replacing deprecated APIs. However, different than their work, our work focuses on the scenario in which there are no examples. 

% \subsection{API Usage Recommendation}
% Several approaches have been developed to recommend and explore how an API can be used~\cite{glassman2018visualizing}. Glassman et al.~\cite{glassman2018visualizing} proposed EXAMPLORE, an tool that summarizes hundreds of code examples for an API in a single view.

On our dataset, AppEvolve produces 10 applicable updates and 44 failed
updates. The original AppEvolve evaluation also showed 4 failed updates.
After investigating the 48 failed updates, we found some common reasons for
the failures, as described below. Table~\ref{table:data_statistic} shows
the number of occurrences of each of these issues.

% \begin{table}
% \caption{Update findings statistic}
% \begin{center}
% \begin{tabular}{ | p{8em} |c|c| } 
%  \hline
%  \textbf{Test Case Type} & \textbf{Detail of Cases} & \textbf{Number of Cases} \\ 
%  \hline
%  Work in AppEvolve & - & 10 \\ 
%  \hline
%  \multirow{7}{8em}{Fixed with simple refactor} & Total cases & 36 \\\cline{2-3} & Return statement & 6 \\\cline{2-3} & If statement & 1 \\\cline{2-3} & Method argument & 4 \\\cline{2-3} & Arithmetic operand & 3 \\\cline{2-3}  & Variable declaration & 12 \\\cline{2-3} & Complex expression & 20 \\\cline{2-3} 
%  \hline
%  \multirow{3}{8em}{Incomplete support of programming language features} & Inheritance & 2\\\cline{2-3} & Static modifier & 1 \\\cline{2-3} & Final modifier & 1\\\cline{2-3}
%  \hline
%  Unknown error & - & 4\\
%  \hline
% \end{tabular}
% \end{center}
% \label{table:data_statistic}
% \end{table}

\begin{table}
\caption{Update findings statistics}
\begin{center}
\begin{tabular}{ | p{12em} |c|c| } 
 \hline
 \textbf{Test Case Type} & \textbf{Subcategory} & \textbf{Occurrences} \\ 
 %\hline
 %Work in AppEvolve & - & 10 \\ 
 \hline
 \multirow{5}{12em}{Statements in the examples and at the target location are structurally different} & Return statement & 6 \\\cline{2-3} & If statement & 1 \\\cline{2-3} & Method argument & 4 \\\cline{2-3} & Arithmetic operand & 3 \\\cline{2-3}  & Declared variable & 12 \\\cline{2-3} 
 \hline
  \multirow{4}{12em}{Object and arguments of the deprecated API method are in the form of complex expressions} & - & 20\\&&\\&&\\&&\\
 \hline
 Edits beyond method boundaries & - & 3\\
\hline
 \multirow{3}{12em}{Incomplete support of programming-language features} & Inheritance & 2\\\cline{2-3} & Static modifier & 1 \\\cline{2-3} & Final modifier & 1\\\cline{2-3}
 \hline
 No examples & - & 1\\
 \hline
 Others & - & 4\\
 \hline
 \multicolumn{2}{|l|}{\bf Total} & 48\\
 \hline
\end{tabular}
\end{center}
\label{table:data_statistic}
\end{table}

\begin{enumerate}
\item {\em The statements in the examples and at the target location are
 structurally different.} In our dataset, it often occurs that the result
 of the deprecated API method invocation is assigned to another variable in
 the example code while the target location invokes the deprecated API
 invocation at the following locations:
\begin{itemize}
\item Return statement: The code in the left hand side of Listing 1 in Table~\ref{tab:mitigatesucc} shows an example of this case. The result of {\tt fromHtml} deprecated method is directly assigned as the return value of the {\tt getTitle} method. 

\item If statement test:  The code in the left hand side of Listing 2 in Table~\ref{tab:mitigatesucc} shows an example of this case.  The result of {\tt requestAudioFocus} deprecated method invocation is used as a condition on whether {\tt play} method should return.

\item Method argument: The code in the left hand side of Listing 3 in Table~\ref{tab:mitigatesucc} shows an example of this case. The result of {\tt getCurrentHour} deprecated method invocation is directly put as the second argument of {\tt String.format} method.

\item Arithmetic operand: The code in the  left hand side of Listing 4 in Table~\ref{tab:mitigatesucc} shows an example of this case. The result of {\tt getCurrentHour} deprecated method invocation is concatenated with ":" string.
\end{itemize}

There are also cases where the example involve assigning the result of the deprecated API method invocation to a variable that has been declared before. The target app declares the variable and directly assigns the result of the deprecated API method invocation. We name this case as {\em declared variable}. 
The code in the left hand side of Listing 5 in Table~\ref{tab:mitigatesucc} shows an example of this case. In this listing, the result of {\tt getCurrentHour} deprecated method invocation is assigned directly when variable {\tt hours} is declared. 

\item {\em Object and arguments of the deprecated API method are in the form of complex expressions.} The invocation of a deprecated method in the example that AppEvolve may learn from may use variables for the object and arguments of the method. These edits do not work when the object and arguments use complex expresssions. AppEvolve is not flexible enough to apply the edits correctly by treating these expressions as variables. The code in the left hand side of Listing 6 in Table~\ref{tab:mitigatesucc} shows an example of this case. The deprecated API method in this listing is {\tt setTextAppearance}.

%\jl{There are two occurrences of the label lst:complexexpress}

\item {\em Edits beyond method boundaries.} AppEvolve cannot learn edits that modify program elements that reside outside the boundaries of the method containing the API usage to be updated. These edits include operations such as adding imports and adding fields to a class. Below is a snippet of an update example that involves edits beyond method boundaries.
\begin{lstlisting}[language=diff,numbers=none,caption=Edits that add imports and a private field,captionpos=b]
18a19
+ import android.location.GnssStatus;
22a24
+ import android.os.Build;
33a36,37
+ private GnssStatus.Callback callback;
41c45,51
- locationManager.addGpsStatusListener(listener);
+ if (android.os.Build.VERSION.SDK_INT >= 
            android.os.Build.VERSION_CODES.N) {
+   locationManager.registerGnssStatusCallback(callback);
+ }
+ else{
+   locationManager.addGpsStatusListener(listener);
+ }
\end{lstlisting}
The deprecated API in the above example is {\tt addGpsStatusListener}. Updating this API requires adding a private field named {\tt callback} of type {\em GnssStatus.Callback}. Unfortunately, since AppEvolve only learn edits inside a method containing the deprecated API usage, it misses this necessary addition.

\item {\em Incomplete support of programming language features.} AppEvolve fails to update cases in which the update involve programming language features such as:
\begin{itemize}
\item Inheritance: The code in the left hand side of Listing 7 in Table~\ref{tab:mitigatefail} shows an example of this case.  The deprecated API method is {\tt setAudioStreamType} of the class {\tt Media Player.} In the above snippet, {\tt TestMediaPlayer} extends {\tt MediaPlayer} and thus it inherits the {\tt setAudioStreamType} method. This method should be updated but AppEvolve does not seem to recognize it due to the use of inheritance.
\item Static modifier:  The code in the left hand side of Listing 8 in Table~\ref{tab:mitigatefail} shows an example of this case.  The deprecated API method {\tt requestAudioFocus} is invoked by {\tt mAudioManager}, which is a static field.

\item Final modifier: The code in the left hand side of Listing 9 in Table~\ref{tab:mitigatefail} shows an example of this case.  Variable {\tt paint} that is used as the deprecated API method {\tt saveLayer} fourth argument is a final field.

\end{itemize}

\item {\em No examples.} There is no example for such API update that can be found in GitHub. 

\item {\em Others.} These include cases that cannot be put to any category above.
\end{enumerate}


\newcolumntype{Y}{>{\centering\arraybackslash}X}

\lstset{
	language=text,numbers=none,
	breaklines=true,
	aboveskip=-7pt,
	belowskip= -6pt
}

\begin{table*}
\centering
\caption{Successful simple refactoring mitigations that allows AppEvolve to generate applicable updates}\label{tab:mitigatesucc}
\begin{tabular}{|p{.10\textwidth}|p{.40\textwidth}|p{.40\textwidth}|}
\hline
\textbf{Listing}
  &
  \textbf{Original Code}
  &
  \textbf{Refactored Code}
 \\ \hline
1. Structurally different: return statement
&
\begin{lstlisting}
Spanned getTitle(){
    return Html.fromHtml(title);
}
\end{lstlisting}
&
\begin{lstlisting}[language=diff]
Spanned getTitle(){
	+ Spanned a;
	+ a = Html.fromHtml(title);
	- return Html.fromHtml(title);
	+ return a;
}
\end{lstlisting}
\\ \hline
2. Structurally different: if statement
&
\begin{lstlisting}
public void play() {
    if (mAudioManager.requestAudioFocus(
    mAudioFocusListener, AudioManager.STREAM_MUSIC,
    AudioManager.AUDIOFOCUS_GAIN) != 
    AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
        return;
    }
}
\end{lstlisting}
&
\begin{lstlisting}[language=diff]
public void play() {
	- if (mAudioManager.requestAudioFocus
	-   (mAudioFocusListener,
	-   AudioManager.STREAM_MUSIC,
	-   AudioManager.AUDIOFOCUS_GAIN) !=
	-   AudioManager.
	-   AUDIOFOCUS_REQUEST_GRANTED) {
	-   return;
	- }
	+ int res;
	+ int arg1=AudioManager.STREAM_MUSIC;
	+ int arg2=AudioManager.AUDIOFOCUS_GAIN;
	+ res = mAudioManager.requestAudioFocus (mAudioFocusListener, arg1, arg2);
	+ if (res != AudioManager
	+   .AUDIOFOCUS_REQUEST_GRANTED) {
	+   return;
	+ }
}
\end{lstlisting}
\\ \hline
3. Structurally different: method argument
&
\begin{lstlisting}
protected String getInputDataString() {
    return String.format("\%02d:\%02d", 
    timePicker.getCurrentHour(), 
    timePicker.getCurrentMinute());
}
\end{lstlisting}
&
\begin{lstlisting}[language=diff]
protected String getInputDataString() {
	+ int hour;
	+ hour = timePicker.getCurrentHour();
	+ return String.format("%02d:%02d", hour,
	+ timePicker.getCurrentMInute());
	- return String.format("\%02d:\%02d", 
	- timePicker.getCurrentHour(), 
	- timePicker.getCurrentMinute());
}
\end{lstlisting}
\\ \hline
4. Structurally different: arithmetic operand
&
\begin{lstlisting}
public void displayTime(View view) {
    String time = timePicker.getCurrentHour() 
	    + ":" + timePicker.getCurrentMinute();
    Toast.makeText(this, time, 
        Toast.LENGTH_SHORT).show();
}
\end{lstlisting}
&
\begin{lstlisting}[language=diff]
public void displayTime(View view) {
	+ int hour;
	+ hour = timePicker.getCurrentHour();
	+ String time = hour + ":" +
	+   timePicker.getCurrentMinute();
	- String time = timePicker.
	-   getCurrentHour() + ":" +
	-   timePicker.getCurrentMinute();
          Toast.makeText(this, time, 
            Toast.LENGTH_SHORT).show();
}
\end{lstlisting}
\\ \hline
5. Direct assignment after declaration
&
\begin{lstlisting}
public Schedule generate() {
    TimePicker timePicker = (TimePicker) activity
        .findViewById(R.id.timePicker);
    int hours = timePicker.getCurrentHour();
    int minutes = timePicker.getCurrentMinute();
    SeekBar seekBar = (SeekBar) activity
        .findViewById(R.id.setLuminosity);
    int luminosity = seekBar.getProgress();
    return new Schedule(hours, minutes, luminosity);
}
\end{lstlisting}
&
\begin{lstlisting}[language=diff]
public Schedule generate() {
    TimePicker timePicker = (TimePicker) activity
        .findViewById(R.id.timePicker);
	+ int hours;
	+ hours = timePicker.getCurrentHour();
	- int hours = timePicker.getCurrentHour();
    int minutes = timePicker.getCurrentMinute();
    SeekBar seekBar = (SeekBar) activity
        .findViewById(R.id.setLuminosity);
    int luminosity = seekBar.getProgress();
    return new Schedule(hours, minutes, luminosity);
}
\end{lstlisting}
\\ \hline
6. Complex expressions
&
\begin{lstlisting}
protected void onClick() {
    ...
    Dialog d = builder.create();
    d.show();
    ((TextView) d.findViewById(android.R.id.message))
        .setTextAppearance(getContext(), 
        android.R.style.TextAppearance_Small);
    ...
}
\end{lstlisting}
&
\begin{lstlisting}[language=diff]
protected void onClick() {  
    ...
    Dialog d = builder.create();
    d.show();
	- ((TextView) d.findViewById(
	-   android.R.id.message))
	- .setTextAppearance(getContext(), 
	-  android.R.style.TextAppearance_Small);
	+ Context c = getContext();
	+ int i = android.R.style.
	+       TextAppearance_Small;
	+ TextView t = ((TextView) d.findViewById
	+   (android.R.id.message)); 
	+ t.setTextAppearance(c, i);
    ...
}
\end{lstlisting}
\\ \hline


\end{tabular} 
\end{table*}

\begin{table}
	\caption{Failed categories that are unhandled by our mitigations}\label{tab:mitigatefail}
\centering
\begin{tabular}{|p{.08\textwidth}|p{.35\textwidth}|}
\hline
\textbf{Listing}
  &
  \textbf{Original Code}
 \\ \hline
7. Incomplete support: inheritance
&
\begin{lstlisting}
public class TestMediaPlayer extends MediaPlayer {
    public TestMediaPlayer() {
        setAudioStreamType(AudioManager.STREAM_MUSIC);
    }
    public TestMediaPlayer(Context testContext, 
        int withResource) throws Exception {
        this();
        AssetFileDescriptor afd = 
            testContext.getResources()
            .openRawResourceFd(withResource);
        assertNotNull(afd);
        setDataSource(afd.getFileDescriptor()
            , afd.getStartOffset(), afd.getLength());
        afd.close();
        prepare();
    }
}
\end{lstlisting}
\\ \hline
8. Incomplete support: static
&
\begin{lstlisting}
private static AudioManager mAudioManager;
public static void requestAudioFocus
    (Context context) {
    if(mAudioManager == null){
        mAudioManager = (AudioManager) 
            context.getApplicationContext()
            .getSystemService
            (Context.AUDIO_SERVICE);
    }
    mAudioManager.requestAudioFocus(
        afChangeListener,
        AudioManager.STREAM_MUSIC,
        AudioManager.AUDIOFOCUS_GAIN);
}
\end{lstlisting}
\\ \hline
9. Incomplete support: final
&
\begin{lstlisting}
private final Paint paint;
@Override protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawColor(Color.GREEN);
    canvas.saveLayer(0, 0, canvas.getWidth(),
        canvas.getHeight(), paint, 
        Canvas.ALL_SAVE_FLAG);
    canvas.restore();
}
\end{lstlisting}
\\ \hline
 \end{tabular}
 \end{table}

  \lstdefinelanguage{text}{
	basicstyle=\ttfamily\extrabold\scriptsize,
	identifierstyle=\color{black},
	aboveskip=5pt,
	belowskip= 5pt
}